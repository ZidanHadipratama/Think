# Branching Frontend Implementation Plan

## **Goal**
Enable users to **Edit**, **Copy**, and **Switch Branches** in the chat interface. The UI must visualize the conversation as a linear thread derived from a tree structure, allowing navigation between different versions of the conversation at any point.

## **Architecture**

### **1. State Management (The Tree)**
Instead of a simple array `messages[]`, the page will now manage:
- **`messageMap`**: `Record<number, Message>` — A lookup table of all messages loaded for this chat.
- **`headId`**: `number | null` — The ID of the latest message in the *currently selected* path.
- **`derivedThread`**: `Message[]` — A computed array generated by tracing from `headId` back to the root (using `parent_id`).

### **2. Component Decomposition**
To keep `page.tsx` clean, we will extract:
- **`components/chat/chat-message.tsx`**: Renders a single message bubble.
    - Handles **Markdown Rendering**.
    - Handles **Copy to Clipboard**.
    - Handles **Edit Mode** (inline textarea).
    - Handles **Branch Navigation** (`< 2 / 5 >`) if multiple siblings exist.
- **`components/chat/message-list.tsx`**: Renders the list of `ChatMessage` components.
    - Responsible for computing siblings and passing `onBranchSwitch` handlers.

## **Execution Steps**

### **Step 1: Create `components/chat/chat-message.tsx`**
This component is the "Smart Bubble".
- **Props:**
    - `message`: The current message data.
    - `siblingCount`: Total number of variations at this node.
    - `currentSiblingIndex`: Which variation is currently shown (1-based).
    - `onBranchSwitch`: Callback `(direction: 'prev' | 'next') => void`.
    - `onEdit`: Callback `(newContent: string) => void` (Triggered on Save).
    - `isLast`: Boolean (to handle loading states for the very last message).
- **Features:**
    - **Hover Actions:** Show Copy/Edit buttons on hover.
    - **Edit Mode:** Toggle between Markdown view and a Textarea.
    - **Navigation:** Render arrows if `siblingCount > 1`.

### **Step 2: Update `app/chat/[[...id]]/page.tsx` (Logic Core)**
- **Fetch Logic:**
    - Update `fetch` to get *all* messages (flat list) instead of just the thread.
    - **Transform:** Convert the flat list into `messageMap` (ID -> Msg) and `childrenMap` (ParentID -> [ChildIDs]).
- **Thread Derivation:**
    - Implement `getThreadFromHead(headId)`: Traces `parent_id` up to the root.
- **Branch Switching Logic:**
    - When a user clicks `<` or `>`, we need to:
        1. Find the current message's parent.
        2. Find the sibling message in the desired direction.
        3. **Crucial:** Find the "latest tip" (leaf) of that *new* sibling's branch. (Default to the most recent interaction on that path).
        4. Update `headId` to that new tip.
- **Sending Messages:**
    - **New Message:** `sendMessage(content, parentId = headId)`.
    - **Editing:** `sendMessage(newContent, parentId = message.parent_id)`. This creates a fork!

### **Step 3: Integration**
- Replace the monolith `messages.map(...)` in `page.tsx` with the new logic and components.

---

## **Visual Interaction Flow**
1. User hovers over a User Message.
2. Clicks "Edit" (Pencil).
3. Changes text -> Clicks "Save".
4. **Action:**
    - API creates new message linked to the *same parent*.
    - Frontend updates `headId` to this new message (it's now the latest).
    - View updates to show the new thread.
5. User sees `< 2 / 2 >` on that message.
6. User clicks `<`.
7. **Action:**
    - View switches back to the *original* message and its subsequent history.

## **Progress**
- [ ] Create `components/chat/chat-message.tsx`
- [ ] Refactor `app/chat/[[...id]]/page.tsx`
